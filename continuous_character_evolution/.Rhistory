m <- mead(d$TF)
m <- mean(d$TF)
v <- var(d$TF)
v/m
slm_1 <- glm(d$TF~1, family = "poisson")
summary(slm_1)
plot(slm_1)
mlm_0 <- glmer(TF~1+(1|groupID), family="poission", data=edu)
mlm_0 <- glmer(d$TF~1+(1|groupID), family="poission", data=edu)
library(arm)
mlm_0 <- glmer(d$TF~1+(1|groupID), family="poission", data=edu)
mlm_0 <- glmer(d$TF~1+(1|groupID), family="poisson", data=edu)
mlm_0 <- glmer(d$TF~1+(1|groupID), family="poisson", data=edu)
mlm_0 <- glmer(TF~1+(1|groupID), family="poisson", data=edu)
edu
mlm_0 <- glmer(TF~1+(1|groupID), family="poisson", data=d)
summary(mlm_0)
mlm_2 <- glmer(TF~ed+matWealth+(1|groupID), family="poisson", data=d)
summary(mlm_2)
vary <- glmer(TF~ed+matWealth+(1+matWealth|groupID), family="poisson", data=d)
summary(vary)
int <- glmer(TF~ed+matWealth+ed:matWealth+(1|groupID), family="poisson", data=d)
summary (int)
anova(int, mlm_2)
library(ggplot2)
mlm_2 <- glmer(TF~married(1|groupID), family="poisson", data=d)
mlm_2 <- glmer(TF~married+(1|groupID), family="poisson", data=d)
sumarry(mlm_2)
summarry(mlm_2)
summary(mlm_2)
setwd("~/GitHub/qmss-2017/plottingPhylogenies")
library(ape)
library(phytools)
library(geiger)
library(phangorn)
plot(PN)
nodelabels()
tiplabels()
N<-read.nexus("pamanyungan.txt") #read in NEXUS file of Pama-Nyungan phylogenetic tree
## WRITE CODE ##
#Wow, doesn't that look ugly?!
#The purpose of this tutorial is give you tools for improving this plot!
#To start with, what is 'PN'?
PN
#PN is an object of class 'phylo'. Typing in just the name of the tree is a good way to check that you're working with the tree you think you are!
#Now let's explore what it means to be an object of class 'phylo'.
## WRITE CODE ##
#what makes up a phylo object? Gives us four parts of the object: edge, Nnode, tip.label, edge.length. Each of these have data associated.
PN$edge
#A long matrix. Each tip and node is assigned a number, with tips assigned numbers 1 through N (where N = number of tips). PN$edge lists which nodes/tips are connected by edges (branches, in the vernacular). This is MUCH easier to conceptualise if you look at the simplest tree possible:
## WRITE CODE ##
#create a tree with three taxa
#plot the tree
#plot the node and tip labels on the tree. Tips come first, so A=1, B=2, C=3 etc
#show the matrix
#You can reconstruct the tree itself with this matrix, which is sometimes useful for checking things, but is otherwise a masochistic waste of time. Moving on!
#PN$Nnode lists, unsurprisingly, the number of nodes (which, for a fully-resolved tree like this one, is the number of tips, minus 1). Again, good for checking!
## WRITE CODE ##
#PN$tip.label lists the tip labels (Pama-Nyungan language names)
## WRITE CODE ##
#PN$edge.length lists the edge lengths (branch lengths), with edges in the same order as PN$edge
## WRITE CODE ##
#The Pama-Nyungan tree has edge lengths, which happen to be in the scale of 'year'. Objects of class "phylo" need not have edge lengths, however:
babytree <- read.tree(text = "(((A,B),(C,D)),E);") #simulate a small tree as you did before
## WRITE CODE ##
# look at the babytree object
# plot it
#On a tree this small, we easily add in the automatically-assigned tip and node labels:
plot(babytree, label.offset = 5) # That looks stupid. 'label.offset' gives a scaling parameter that lets you determine how much space there is between the end of the branch and the label. Change it to see what it does. 0.2 is a much better value
## WRITE CODE ##
#node labels
#tip labels
#Note that node and tip labels are fairly ugly on larger trees:
plot(PN)
nodelabels()
tiplabels() #hideous!
#Let's save our example tree before returning to the Pama-Nyungan tree
## WRITE CODE ##
#We just saved it as a NEXUS file, to match the format of the Pama-Nyungan tree. We could also have saved in Newick format:
write.tree(babytree, file="tinyexampletree-newick.tre")
#You could now open these in another programme such as FigTree.
########################################
## Section 2: manipulating trees
########################################
#Okay, back to Pama-Nyungan
plot(PN,show.tip.label=FALSE) #this turns off the tip labels, which are illegible at this scale
#We can use R to manipulate the tree. For example, maybe you're only interested in part of the Pama-Nyungan phylogeny?
## WRITE CODE ##
# extract a clade that descends from an arbitrary node number (here, 300). Choose a different number to check.
#plot this subset
#oooh, something you can read!
#Figuring out what node you actually want can be messy on larger trees.
#A handy way of figuring out what node you want uses the command 'mrca', which stands for 'Most Recent Common Ancestor'
#The MRCA is the latest possible (i.e., most recent) node that contains the specified tips as a monophyletic clade
## WRITE CODE ##
# find the MRCA of Birrpayi and Dharawal
#This should be 300. Do you see why? Look again at the plot of 'subsetPN'
## WRITE CODE ##
#create a subset
#plot it
#Now you try. Pick some languages from PN$tip.label and see what their smallest possible monophyletic clade looks like.
PN$tip.label
## WRITE CODE ##
#We can also remove languages from the tree, for example because we don't have data for them, or becausethey're inconvenient for our purposes today
tipswithlongnames <- c("MaryRiverandBunyaBunyaCountry","WalmajarriBilliluna","NorthernNyangumarta")
## WRITE CODE ##
#create phylo object without longnames
#plot it
#The drop.tip command is very useful for editing trees
#Note that the drop.tip command will also work across lists of multiple phylogenies -- class 'multiPhylo' -- using the command lapply.
#Now you try. What if you want a tree that just shows the languages 'Umpila', 'Biri', and 'Yidiny'?
#HINT: try to use the command 'setdiff'. The elements of setdiff(x,y) are those elements in x but not in y.
#Depending on how good your R is, this may be a very hard problem, so don't worry.
## WRITE CODE ##
# work from inside out here. 'setdiff' will give us the members of PN that are NOT our 3 languages of interest. 'drop.tip' will then drop these from the tree, and we'll assign the "leftover" bits of the tree to 'PN.uby'
#What if you sample 10 languages at random (using the command 'sample') and just plot those?
#HINT: remember that PN$tip.label will list all tips and that there are 194 languages total.
#The answer to this mini-exercise is at the end of this tutorial.
#The commands 'getExtant' and 'getExtinct' will create lists of tips that, respectively, do (18) and do not (176) extend to the present.
#Using the command drop.tip, what would you do if you want a tree of just extant languages?
#The answer to this mini-exercise is at the end of this tutorial.
#Let's return to our sample tree for this next one:
plot(PN)
nodelabels()
tiplabels()
#node labels
#tip labels
#Note that node and tip labels are fairly ugly on larger trees:
plot(PN)
nodelabels()
tiplabels() #hideous!
#Let's save our example tree before returning to the Pama-Nyungan tree
## WRITE CODE ##
#We just saved it as a NEXUS file, to match the format of the Pama-Nyungan tree. We could also have saved in Newick format:
write.tree(babytree, file="tinyexampletree-newick.tre")
#You could now open these in another programme such as FigTree.
########################################
## Section 2: manipulating trees
########################################
#Okay, back to Pama-Nyungan
plot(PN,show.tip.label=FALSE) #this turns off the tip labels, which are illegible at this scale
#We can use R to manipulate the tree. For example, maybe you're only interested in part of the Pama-Nyungan phylogeny?
## WRITE CODE ##
# extract a clade that descends from an arbitrary node number (here, 300). Choose a different number to check.
#plot this subset
#oooh, something you can read!
#Figuring out what node you actually want can be messy on larger trees.
#A handy way of figuring out what node you want uses the command 'mrca', which stands for 'Most Recent Common Ancestor'
#The MRCA is the latest possible (i.e., most recent) node that contains the specified tips as a monophyletic clade
## WRITE CODE ##
# find the MRCA of Birrpayi and Dharawal
#This should be 300. Do you see why? Look again at the plot of 'subsetPN'
## WRITE CODE ##
#create a subset
#plot it
#Now you try. Pick some languages from PN$tip.label and see what their smallest possible monophyletic clade looks like.
PN$tip.label
## WRITE CODE ##
#We can also remove languages from the tree, for example because we don't have data for them, or becausethey're inconvenient for our purposes today
tipswithlongnames <- c("MaryRiverandBunyaBunyaCountry","WalmajarriBilliluna","NorthernNyangumarta")
## WRITE CODE ##
#create phylo object without longnames
#plot it
#The drop.tip command is very useful for editing trees
#Note that the drop.tip command will also work across lists of multiple phylogenies -- class 'multiPhylo' -- using the command lapply.
#Now you try. What if you want a tree that just shows the languages 'Umpila', 'Biri', and 'Yidiny'?
#HINT: try to use the command 'setdiff'. The elements of setdiff(x,y) are those elements in x but not in y.
#Depending on how good your R is, this may be a very hard problem, so don't worry.
## WRITE CODE ##
# work from inside out here. 'setdiff' will give us the members of PN that are NOT our 3 languages of interest. 'drop.tip' will then drop these from the tree, and we'll assign the "leftover" bits of the tree to 'PN.uby'
#What if you sample 10 languages at random (using the command 'sample') and just plot those?
#HINT: remember that PN$tip.label will list all tips and that there are 194 languages total.
#The answer to this mini-exercise is at the end of this tutorial.
#The commands 'getExtant' and 'getExtinct' will create lists of tips that, respectively, do (18) and do not (176) extend to the present.
#Using the command drop.tip, what would you do if you want a tree of just extant languages?
#The answer to this mini-exercise is at the end of this tutorial.
#Let's return to our sample tree for this next one:
plot(babytree)
nodelabels()
#At the moment, it reads top-to-bottom E, D, C, B, A, which is annoying. Let's try to rotate the tree.
## WRITE CODE ##
#Do you see what just happened? That's better, but not quite what we want. Let's try this:
## WRITE CODE ##
#We can also re-root the tree:
## WRITE CODE ##
#Remember how our tree didn't have edge lengths? What happens if we try to re-root a tree that has edge lengths?
## WRITE CODE ##
#re-root tree at node 321
#plot it
#If we don't want to deal with node labels, we can also root by a specific taxon:
## WRITE CODE ##
#re-root tree with language "GuuguYimidhirr"
#plot it
#This is useful if your analysis contains a known outgroup!
#One more piece of phylogeny manipulation, and then we'll move on to the actual graphics.
#You might have reason to want to know the phylogenetic distance between two languages.
#For example, you might want to know if phylogenetic separation correlates with geographic separation, or differences in cultural traits, etc.
#One way to extract this information uses the command 'cophenetic.'
cophenetic(PN)["Dharumbal", "WikMungkan"]
#This gives you an answer in the units of the branch lengths, which may or may not be meaningful in terms of estimated years of separation.
#In this case, branch lengths = years, so Dharumbal and WikMungkan have been separated by an estimated cophenetic(PN)["Dharumbal", "WikMungkan"]/2 years.
#Running the 'cophenetic' command on an entire tree gives you a matrix of all pairwise distances:
## WRITE CODE ##
########################################
## Section 3: graphics
########################################
#Okay, back to graphics. So far, we have a Pama-Nyungan phylogeny that looks like this:
plot(PN,show.tip.label=FALSE)
#The plot.phylo command is really flexible, though!
#For example, we can plot various types of trees:
## WRITE CODE ##
#cladogram
#fan tree
#radial tree
#We can change the edge colors/thickness:
## WRITE CODE ##
#The edge.color command can take a vector, so with some careful coding you can color the edges by, say, a particular trait.
## WRITE CODE ##
# How do we identify which edges belong to tips?
## WRITE CODE ##
#create a vector of 'black' with 2N length
for(i in 1:(2*N)){
if(PN$edge[i,2] < N+2){colorscheme[i]<-rainbow(N+1)[PN$edge[i,2]]}
}
#Clunky, but it works, and you should be able to figure out what is going on
colorscheme
plot(PN,edge.color=colorscheme,edge.width=2,show.tip.label=FALSE)
#Okay, moving away from rainbow silliness, let's say that you wanted to plot an ancestral state.
#Because this is an example, let's use as our character the number of letters in the language name, because that's obviously an important cultural trait! :-)
trait<-nchar(PN$tip.label)
names(trait)<-PN$tip.label
trait
x<-contMap(PN,trait,plot=FALSE) #reconstruct ancestral state using phytools function 'fastAnc'
#This is going to get a little messy, so let's only label every 10th tip
for(i in 1:(x$tree$Nnode+1)){
if( i %% 10 !=0){	x$tree$tip.label[i]<-""}
}
plot(x)
#Does something look weird about the color scheme to you?
#Remember how we removed the tips with really long names? Yeah, let's do that again.
tipswithlongnames <- names(trait[trait>15])
PN.shortnames <- drop.tip(PN, tipswithlongnames)
#Now let's re-run the code:
trait<-nchar(PN.shortnames$tip.label)
names(trait)<-PN.shortnames$tip.label
x1<-contMap(PN.shortnames,trait,plot=FALSE) #reconstruct ancestral state using phytools function 'fastAnc'
#Only label every 10th tip
for(i in 1:(x1$tree$Nnode+1)){
if( i %% 10 !=0){	x1$tree$tip.label[i]<-""}
}
plot(x1) #this looks so much nicer!
#we don't really expect language name length to display any phylogenetic signal (or DO WE?)
#Let's try plotting the ancestral states of discrete characters.
#We start by simulating a trait.
sims<-sample(c("S1","S2","S3"), PN$Nnode+1, replace=TRUE) #this is simulating a character (S1-S3) at random, with no regard for phylogeny.
names(sims)<-PN$tip.label
sims
#We can first plot the characters on the tips:
plot(PN,type="fan",show.tip.label=FALSE)
cols<-setNames(palette()[1:length(unique(sims))],sort(unique(sims))) #setting a color palette
cols
tiplabels(pie=to.matrix(sims,sort(unique(sims))),piecol=cols,cex=0.3)
add.simmap.legend(colors=cols) #click where you want to draw your legend!
#Then we can add ancestral states probabilities for each node, again using 'ace':
fitER<-ace(sims,PN,model="ER",type="discrete")
#ER here stands for 'equal-rates'; ace can estimate ancestral states under a few other models, and the packages 'diversitree' has even more flexibility.
#Note diversitree requires  ultrametric trees, or trees with all of the tips being the same age, i.e., no extinct languages.
#We can inspect the estimated probabilities of each trait for each node.
fitER$lik.anc
#See how all of the node likelihoods are equal? That's a problem; it's indicating that the algorithm has failed in some way.
#'ace' is known to stop working over long branch lengths, so let's try shrinking the tree.
PN.scaled<-PN
PN.scaled$edge.length <- PN$edge.length/100
fitER<-ace(sims,PN.scaled,model="ER",type="discrete")
fitER$lik.anc
#Oh, look, that worked! (If you got an error about 'NaNs', you accidentally divided by 0, don't worry, re-run the 'sample' code and try again.)
#Add the node labels:
nodelabels(node=1:PN$Nnode+Ntip(PN),
pie=fitER$lik.anc,piecol=cols,cex=0.5)
#Isn't this pretty?
#(Actually, no, it probably isn't, because this was randomized data. Real-world data will probably display greater phylogenetic signal.)
#If you want to simulate some discrete traits with phylogenetic signal, you can use this code:
q<-list(rbind(c(-.5, .5), c(.5, -.5))) #this is a matrix of rates of evolution from state 1 to state 2.
q
sims<-sim.char(PN, q, model="discrete", n=1) #simulates one character under the discrete model of evolution described by q, over the phylogeny PN
#Now go back and re-run the tip and node ancestral states and plotting above from line 281
#What is the relationship between the q matrix and what you see?
#Try plotting discrete ancestral states with another simulated dataset, this one more similar to real-world data. Or, just make the first 64 languages S1, the next 64 S2, and the final 65 S3.
#Note, incidentally, that there are ways of estimating ancestral states when some node states are known (historical language/cultural data).
#One can also overlay these sorts of phylogenies onto maps, to visually check for spatial signal, or into morphospace.
#We're not going to cover this here, but Google is your friend.
#One final type of phylogenetic graphs: lineage-through-time (LTT) plots.
#LTT plots count the accumulation of lineages (languages) through time.
#They are super-easy in R.
ltt.plot(PN, xlab = "Time", ylab = "N")
#This shows the accumulation of languages over the past 5,000 or so years, starting with proto-Pama-Nyungan.
#There seem to have been no particular bursts of language speciation/extinction, at least not until the present day.
#What would an LTT plot look like if there had been a major diversification or extinction event in a language family's history?
#One can also do LTT plots on discrete traits, showing the accumulation of particular traits. Google is your friend.
########################################
## Section 4: ggtree
########################################
#Okay, one final set of examples: ggtree.
#ggtree extends the ggplot2 package and is brand-new (published earlier in 2017)
#To install:
source("https://bioconductor.org/biocLite.R")
biocLite("ggtree",type="source")
name(PN)
names(PN)
PN<-read.nexus("pamanyungan.txt")
names(PN)
PN$edge
abc <- read.tree (text = "(A, B), C);")
abc <- read.tree (text = "((A, B), C);")
plot.phylo(abc, type="clado")
tiplabels()
nodelabels()
abc$edge
PN
PN$Nnode
str(PN)
tiplabels()
PN$tip.lable
PN$tip.label
babytree <- read.tree(text = "(((A,B),(C,D)),E);")
plot(babytree)
plot.phylo(babytree, type="clado")
plot(babytree, label.offset = 5)
plot(babytree, label.offset = 10)
plot(babytree, label.offset = 1)
plot(babytree, label.offset = 0/5)
plot(babytree, label.offset = 0.5)
plot(babytree, label.offset = 0)
plot(babytree, label.offset = 0.1)
nodelabels()
tiplabels()
plot(PN)
plot.phylo(PN)
nodelabels()
plot(PN)
nodelables()
nodelabels()
write.nexus(babytree, file="babytree.nex")
plot(PN)
tiplabels()
..
..
.
plot(PN)
subsetPN <- extract.clade(PN, 300)
plot(subsetPN)
plot(subsetPN)
randomnoe <- mrca(PN)
randomnoe <- mrca(PN)['Dharawal', 'Dhurga']
randomnoe
randomnode < mrca(PN)['Dharawal', 'Dhurga']
randomnode <- mrca(PN)['Dharawal', 'Dhurga']
subsetPN1 <- extract.clade(PN, randomnode)
plot(subsetPN1)
tipnodes
tiplabels()
nodelabels()
tipswithlongnames
PN.shortnames <- drop.tip(PN, tipswithlongnames)
plot(PN.shortnames)
setdiff?
setdiff(?)
d <- PN['Umpila'', 'Biri'', 'Yidiny'']
?setdiff
plot(babytree)
nodelabels()
babytree1 <- rotate(babytree, 6)
plot(babytree1)
babytree1 <- rotate(babytree, 8)
plot(babytree1)
nodelabels()
babytree3 <- root(babytree, node = 7)
plot(babytree3)
tiplabels()
nodelabels()
plot(babytree1)
nodelabels()
babytree3 <- root(babytree1, node = 7)
plot(babytree3)
plot(babytree1)
plot(babytree3)
nodelabels()
cophenetic(PN)
plot(PN, edge.color = "blue")
plot(PN, edge.color = "blue", show.tip.label = F)
trait<-nchar(PN$tip.label)
names(trait)<-PN$tip.label
trait
x <- contMap(PN, trait, plot=FALSE)
for(i in 1:(x$tree$Nnode+1)){
if( i %% 10 !=0){	x$tree$tip.label[i]<-""}
}
plot(x)
tipswithlongnames <- names(trait[trait>15])
PN.shortnames <- drop.tip(PN, tipswithlongnames)
plot(x)
sims <- sample(c("S1", "S2", "S3"))
tipswithlongnames <- names(trait[trait>15])
PN.shortnames <- drop.tip(PN, tipswithlongnames)
#Now let's re-run the code:
trait<-nchar(PN.shortnames$tip.label)
names(trait)<-PN.shortnames$tip.label
x1<-contMap(PN.shortnames,trait,plot=FALSE) #reconstruct ancestral state using phytools function 'fastAnc'
#Only label every 10th tip
for(i in 1:(x1$tree$Nnode+1)){
if( i %% 10 !=0){	x1$tree$tip.label[i]<-""}
}
plot(x1) #this looks so much nicer!
#we don't really expect language name length to display any phylogenetic signal (or DO WE?)
#Let's try plotting the ancestral states of discrete characters.
#We start by simulating a trait.
sims<-sample(c("S1","S2","S3"), PN$Nnode+1, replace=TRUE) #this is simulating a character (S1-S3) at random, with no regard for phylogeny.
names(sims)<-PN$tip.label
sims
#We can first plot the characters on the tips:
plot(PN,type="fan",show.tip.label=FALSE)
cols<-setNames(palette()[1:length(unique(sims))],sort(unique(sims))) #setting a color palette
cols
tiplabels(pie=to.matrix(sims,sort(unique(sims))),piecol=cols,cex=0.3)
add.simmap.legend(colors=cols) #click where you want to draw your legend!
nodelabels()
ggtree(PN)
library(ggtree)
install.packages("ggtree", lib="/Library/Frameworks/R.framework/Versions/3.4/Resources/library")
library(ggtree)
source("https://bioconductor.org/biocLite.R")
biocLite("ggtree",type="source")
a
a
setwd("~/GitHub/qmss-2017/continuous_character_evolution")
library(ape)
library(phytools)
library(geiger)
library(geiger)
install.packages("geiger", lib="/Library/Frameworks/R.framework/Versions/3.4/Resources/library")
library(geiger)
phoible_all <- read.csv("PHOIBLE_cleaned_with_tree_names.txt", header = T, na.strings = c("", NA), sep = "\t")
plot
plot(phoible_all)
plot(phoible_all$Consonants, phoible_all$Vowels)
dev.off
plot(phoible_all$Consonants, phoible_all$Vowels)
glottlog_full_tree <- read.newick(file = 'glottolog_full_tree_pruned.tree')
glottlog_full_tree
consonats <- phoible_all$Consonants
names(consonants)
names(consonants) <- phoible_all$TreeName
names(consonats) <- phoible_all$TreeName
mod_l_1 <- fitContinuous(phy = glottolog_full_tree, dat = consonants, model = "BM")
mod_l_1 <- fitContinuous(phy = glottolog_full_tree, dat = consonats, model = "BM")
mod_l_1 <- fitContinuous(phy = glottolog_full_tree, dat = consonats, model = "BM")
mod_l_1 <- fitContinuous(phy = "glottolog_full_tree", dat = "consonants", model = "BM")
mod_l_1 <- fitContinuous(phy = "glottolog_full_tree", dat = "consonats", model = "BM")
mod_l_1 <- fitContinuous(phy = glottolog_full_tree, dat = consonants, model = "BM")
mod_l_1 <- fitContinuous(phy = "glottolog_full_tree", dat = "consonats", model = "BM")
mod_l_1 <- fitContinuous(phy = glottolog_full_tree, dat = consonants, model = "BM")
mod_l_1 <- fitContinuous(phy = glottolog_full_tree, dat = consonats, model = "BM")
mod_l_1 <- fitContinuous(phy = glottlog_full_tree, dat = consonats, model = "BM")
glottlog_full_tree <- glottolog_full_tree
glottolog_full_tree <- glottlog_full_tree
consonants <- consonats
mod_l_est <- fitContinuous(phy = glottolog_full_tree, dat = consonants, model = "lambda")
mod_l_est
mod_l_1$opt$lnL
mod_l_est$opt$lnL
LR < 2 * (logLik(mod_l_est) - logLik(mod_l_1))
LR <- 2 * (logLik(mod_l_est) - logLik(mod_l_1))
LR
p <- pchisq(LR, df = mod_l_est$opt$k - mod_l_1$opt$k, lower.trail = F)
P <- pchisq(LR, df = mod_l_est$opt$k - mod_l_1$opt$k, lower.tail = FALSE)
p <- pchisq(LR, df = mod_l_est$opt$k - mod_l_1$opt$k, lower.trail = F)
p <- pchisq(LR, df = mod_l_est$opt$k - mod_l_1$opt$k, lower.tail = F)
p
mod_l_est$opt$k
phoible_IE <- read.csv(file = "PHOIBLE_IE.txt", sep = "\t")
IE_tree <- read.newick(file = "glottolog_IE.tree")
IE_tree <- read.newick(file = "glottolog_IE.tree")
IE_tree
plot(IE_tree)
ASE <- ace(x = phoible_IE$Consonants, phy = IE_tree, method = "ML")
ASE
plot.phylo(IE_tree, label.offset = 2)
tiplabels(phoible_IE$Consonants, width = 0.3)
nodelabels(round(ASE$ace, 0), width = 0.3)
library(caper) # pgls
library(phytools) # read.newick
install.packages("caper", lib="/Library/Frameworks/R.framework/Versions/3.4/Resources/library")
library(caper) # pgls
library(phytools) # read.newick
phoible_all <- read.csv("PHOIBLE_cleaned_with_tree_names.txt", header = TRUE, na.strings=c("", "NA"), sep = "\t")
plot(phoible_all$Consonants,phoible_all$Vowels)
res <- lm(Consonants ~ Vowels, data = phoible_all)
summary(res)
compa_data <- comparative.data(glottolog_full_tree, phoible_all, names.col = TreeName)
res <- pgls(Consonants ~ Vowels, compa_data, lambda = "ML") # this may take 30 seconds or so
summary(res)
View(phoible_all)
res <- pgls(Tones ~ Vowels, compa_data, lambda = "ML") # this may take 30 seconds or so
plot(Tones, Vowels)
Tones <- phoible_all$Tones
Vowels <- phoible_all$Vowels
plot(Tones, Vowels)
plot(phoible_all$Consonants, phoible_all$Vowels)
plot(phoible_all$Tones, phoible_all$Vowels)
summary(res)
abline()
?abline
